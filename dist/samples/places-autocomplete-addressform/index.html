<!DOCTYPE html>
<html>
  <head>
    <title>Place Autocomplete Address Form</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <link
      href="https://unpkg.com/material-components-web@6.0.0/dist/material-components-web.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <head>
      <link
        rel="stylesheet"
        href="https://fonts.googleapis.com/icon?family=Material+Icons"
      />
    </head>

    <style type="text/css">
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }

      /* Optional: Makes the sample page fill the window. */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      :root {
        --mdc-theme-primary: #1a73e8;
        --mdc-theme-secondary: #rgb(225, 245, 254);
        --mdc-theme-on-primary: #fff;
        --mdc-theme-on-secondary: rgb(1, 87, 155);
      }

      .mdc-text-field--focused:not(.mdc-text-field--disabled)
        .mdc-floating-label {
        color: var(--mdc-theme-primary);
      }

      .addressform {
        display: flex;
        width: 300px;
        margin: 20px auto;
      }

      .slimfield {
        display: flex;
        flex-direction: row;
        width: 100px;
        margin: 20px auto;
      }
    </style>
    <script>
      "use strict";

      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (
            Array.isArray(o) ||
            (it = _unsupportedIterableToArray(o)) ||
            (allowArrayLike && o && typeof o.length === "number")
          ) {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
              s: F,
              n: function n() {
                if (i >= o.length) return { done: true };
                return { done: false, value: o[i++] };
              },
              e: function e(_e) {
                throw _e;
              },
              f: F,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var normalCompletion = true,
          didErr = false,
          err;
        return {
          s: function s() {
            it = o[Symbol.iterator]();
          },
          n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function e(_e2) {
            didErr = true;
            err = _e2;
          },
          f: function f() {
            try {
              if (!normalCompletion && it.return != null) it.return();
            } finally {
              if (didErr) throw err;
            }
          },
        };
      }

      function _toConsumableArray(arr) {
        return (
          _arrayWithoutHoles(arr) ||
          _iterableToArray(arr) ||
          _unsupportedIterableToArray(arr) ||
          _nonIterableSpread()
        );
      }

      function _nonIterableSpread() {
        throw new TypeError(
          "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (
          n === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
        )
          return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }

      // This sample uses the Places Autocomplete widget to help the user select a
      // place, then it retrieves the address components associated with that
      // place, and then it populates the form fields with those details.
      // This sample requires the Places library. Include the libraries=places
      // parameter when you first load the API. For example:
      // <script
      // src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBIwzALxUPNbatRBj3Xi1Uhp0fFzwWNBkE&libraries=places">
      var autocomplete;
      var address1Field;
      var address2Field;
      var postalField;
      var componentFields = [
        "address2",
        "locality",
        "administrative_area_level_1",
        "postal_code",
        "country",
      ];
      var componentLength = {
        street_number: "long_name",
        route: "short_name",
        locality: "long_name",
        administrative_area_level_1: "short_name",
        postal_code: "long_name",
        postal_code_suffix: "long_name",
        country: "long_name",
      };

      function initAutocomplete() {
        _toConsumableArray(
          document.querySelectorAll(".mdc-text-field")
        ).forEach(function (el) {
          return new mdc.textField.MDCTextField(el);
        });

        address1Field = document.querySelector("#address1");
        address2Field = document.querySelector("#address2");
        postalField = document.querySelector("#postal_code");
        console.log(address1Field.value + "address1");
        console.log(address2Field.value + "address2"); // Create the autocomplete object, restricting the search predictions to
        // geographical location types.

        autocomplete = new google.maps.places.Autocomplete(address1Field, {
          componentRestrictions: {
            country: "us",
          },
          fields: ["address_components", "geometry"],
          types: ["address"],
        }); // When the user selects an address from the drop-down, populate the
        // address fields in the form.

        autocomplete.addListener("place_changed", fillInAddress);
      }

      function fillInAddress() {
        // Get the place details from the autocomplete object.
        var place = autocomplete.getPlace();
        var address1 = "";
        var postcode = "";

        var _iterator = _createForOfIteratorHelper(componentFields),
          _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var component = _step.value;
            var classname = component + "-outer";
            var element = document.getElementById(classname);
            var pattern = new RegExp(
              "(?:)" + "mdc-text-field--disabled" + "(?:)",
              "g"
            );
            element.className = element.className.replace(pattern, "");
            document.getElementById(component).disabled = false;
          } // Get each component of the address from the place details,
          // and then fill-in the corresponding field on the form.
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(place.address_components),
          _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _component = _step2.value;
            var addressType = _component.types[0];

            switch (addressType) {
              case "street_number": {
                address1 =
                  _component[componentLength[addressType]] + " " + address1;
                break;
              }

              case "route": {
                address1 += _component[componentLength[addressType]];
                break;
              }

              case "postal_code": {
                postcode = _component[componentLength[addressType]] + postcode;
                break;
              }

              case "postal_code_suffix": {
                postcode += "-" + _component[componentLength[addressType]];
                break;
              }

              default: {
                if (componentLength[addressType]) {
                  var val = _component[componentLength[addressType]]; // eslint-disable-next-line prettier/prettier

                  document.getElementById(addressType).value = val;
                }

                break;
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        console.log(address1);
        console.log(postcode);
        address1Field.value = address1;
        postalField.value = postcode; // After filling the form with address components from the Autocomplete
        // prediction, set cursor focus on the second address line to encourage
        // entry of subpremise information such as apartment, unit, or floor number.

        address2Field.focus();
      }
    </script>
  </head>
  <body>
    <!-- Note: The address components in this sample are based on North American address format. You might need to adjust them for the locations relevant to your app. For more information, see
https://developers.google.com/maps/documentation/javascript/examples/places-autocomplete-addressform
    -->

    <form action="" method="get">
      <label
        class="mdc-text-field mdc-text-field--outlined addressform"
        id="address1-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label" id="address1label"
              >Street address</span
            >
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="address1"
          name="address1"
          aria-labelledby="address1label"
          autocomplete="new-password"
          required
        />
      </label>
      <label
        class="mdc-text-field mdc-text-field--outlined mdc-text-field--disabled addressform"
        id="address2-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label" id="address2label">Address 2</span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="address2"
          name="address2"
          aria-labelledby="address2label"
          autocomplete="new-password"
          disabled
        />
      </label>
      <label
        class="mdc-text-field mdc-text-field--outlined mdc-text-field--disabled addressform"
        id="locality-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label" id="localitylabel">City</span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="locality"
          name="locality"
          aria-labelledby="localitylabel"
          autocomplete="new-password"
          required
          disabled
        />
      </label>
      <label
        class="mdc-text-field mdc-text-field--outlined mdc-text-field--disabled slimfield"
        id="administrative_area_level_1-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span
              class="mdc-floating-label"
              id="administrative_area_level_1label"
              >State/Province</span
            >
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="administrative_area_level_1"
          name="administrative_area_level_1"
          aria-labelledby="administrative_area_level_1label"
          autocomplete="new-password"
          disabled
        />
      </label>
      <label
        class="mdc-text-field mdc-text-field--outlined mdc-text-field--disabled slimfield"
        id="postal_code-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label" id="postal_codelabel"
              >Postal code</span
            >
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="postal_code"
          name="postal_code"
          aria-labelledby="postal_codelabel"
          autocomplete="new-password"
          disabled
        />
      </label>
      <label
        class="mdc-text-field mdc-text-field--outlined mdc-text-field--disabled addressform"
        id="country-outer"
      >
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label" id="countrylabel">Country</span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
        <input
          class="mdc-text-field__input"
          type="text"
          id="country"
          name="country"
          aria-labelledby="countrylabel"
          autocomplete="new-password"
          disabled
        />
      </label>
    </form>

    <!-- old code
<form action="" method="get">
  <div class="form-example">
    <label for="address2">Address line 2: </label>
    <input type="text" name="address2" id="address2" autocomplete="off" disabled="true" />
  </div>
  <div class="form-example">
    <label for="locality">City </label>
    <input type="text" name="locality" id="locality" autocomplete="off" disabled="true" />
  </div>
  <div class="form-example">
    <label for="administrative_area_level_1">State/Province </label>
    <input type="text" name="administrative_area_level_1" id="administrative_area_level_1" autocomplete="off" disabled="true" />
  </div>
  <div class="form-example">
    <label for="postal_code">Postal code </label>
    <input type="text" name="postal_code" id="postal_code" autocomplete="off" disabled="true" />
  </div>
  <div class="form-example">
    <label for="country">Country </label>
    <input type="text" name="country" id="country" autocomplete="off" disabled="true" />
  </div>
</form>
    -->

    <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBIwzALxUPNbatRBj3Xi1Uhp0fFzwWNBkE&callback=initAutocomplete&libraries=places&v=weekly"
      async
    ></script>
  </body>
</html>
